#!/usr/bin/perl -w
#########################################################
#                                                       #
#                                                       #
#       SNMP Interface Traffic Check Plugin             #
#                      for                              #
#                Icinga / Nagios                        #
#                                                       #
#        Version 1.0.0 (September 22, 2022)             #
#                by Bob McLoughlin                      #
#         E-mail: rmcloughlin@outlook.com               #
#                                                       #
#                                                       #
# Based on:                                             #
# check_iftraffic64.pl                                  #
#       Version .77 (March 27, 2018)                    #
# ( by Greg Frater                                      #
#       E-mail: gregATfraterfactory.com )               #
#                                                       #
# Which was further based on:                           #
# check_iftraffic.pl                                    #
#       Version     (June 14, 2005)                     #
# ( by Markus Werner                                    #
#       E-mail: mw+nagios@wobcom.de )                   #
#                                                       #
# Version History                                       #
#   - Refer to CHANGELOG.md                             #
#                                                       #
#       Like the original, this plugin is distributed   #
# under the GNU GPL license. You may re-destribute only #
# according to the terms of the GNU GPL.                #
#                                                       #
#########################################################
#########################################################
#                                                       #
# DEPENDS On                                            #
# Net-SNMP                                              #
#                                                       #
#########################################################

# Set Perl environ
use strict;
use Data::Dumper;
use SNMP;
use Getopt::Long;
&Getopt::Long::config('bundling');

# Set script parameters
my $error;
my $host_address;
my $iface_descr;
my $iface_number;
my $iface_speed;
my $iface_speedOut;
my $ifspeed64;
my $ifspeed32;
my $inbytes64;
my $inbytes32;
my $outbytes64;
my $outbytes32;
my $in_ave 	 = 0;
my $pin_ave 	 = 0;
my $in_tot 	 = 0;
my $index_list;
my $max_value; #added 20050614 by mw
my $max_bytes;
my $opt_h;
my $out_ave	 = 0;
my $pout_ave	 = 0;
my $port 	 = 161;
my $out_tot 	 = 0;
my $response;
my $session;
my @snmpoids;
my $units;
my $disableperf;
my $max_speed;
my $max_speedOut;
my $pdInSpeed    = 1;
my $pdOutSpeed   = 1;
my $pdInUsage    = 1;
my $pdOutUsage   = 1;
my $pdInBwdth    = 1;
my $pdOutBwdth   = 1;
my $pdInAbs      = 1;
my $pdOutAbs     = 1;

# SNMP OIDs for Traffic
my $snmpIfOperStatus 	= '1.3.6.1.2.1.2.2.1.8';	# Operational state of interface (i.e. 1-up, 2-down, etc.)
my $snmpIfInOctets32  	= '1.3.6.1.2.1.2.2.1.10';	# Total Octets entering interface (in) - 32 bit counter
my $snmpIfOutOctets32 	= '1.3.6.1.2.1.2.2.1.16';	# Total Octets leaving interface (out) - 32 bit counter
my $snmpIfInOctets  	= '1.3.6.1.2.1.31.1.1.1.6';	# Total Octets entering interface (in) - 64 bit counter
my $snmpIfOutOctets 	= '1.3.6.1.2.1.31.1.1.1.10';	# Total Octets leaving interface (out) - 64 bit counter
my $snmpIfDescr     	= '1.3.6.1.2.1.2.2.1.2';	# Textual string describing interface
my $snmpIfSpeed32     	= '1.3.6.1.2.1.2.2.1.5'; 	# bits per second
my $snmpIfSpeed    	= '1.3.6.1.2.1.31.1.1.1.15'; 	# Mbits per second
my $snmpIPAdEntIfIndex 	= '1.3.6.1.2.1.4.20.1.2'; 	# Index of interface using hosts IP addr


# Path to  tmp files
my $TRAFFIC_FILE = "/usr/local/nagios/libexec/traffic/";

# Create tmp file location if it does not exist
if ( ! -d $TRAFFIC_FILE ) {
	mkdir $TRAFFIC_FILE;
}

# changes sos 20090717 UNKNOWN must be 3
# Set status codes
my %STATUS_CODE =
  ( 'UNKNOWN' => '3', 'OK' => '0', 'WARNING' => '1', 'CRITICAL' => '2' );

#default values;
my $bits          = undef; 
my $COMMUNITY	  = "public";
my $crit_usage	  = 98;
my $debug         = 0;
my $force	  = undef;
my $if_status	  = '4';
my ( $in_bytes, $out_bytes, $in_bytes32, $out_bytes32 ) = 0;
my $label         = "";
my $output        = "";
my $snmp_version  = 2;
my $state         = "UNKNOWN";
my $suffix        = "B";
my $thirtytwo     = undef;
my $use_reg       = undef;  # Use Regexp for name
my $warn_usage    = 85;
my $timeout       = 1000000;
my $username      = undef;
my $authpass      = undef;  # changed 20220919 by rm
my $authproto     = 'MD5';
my $authkey       = undef;  # added 20220919 by rm
my $privpass      = undef;  # changed 20220919 by rm
my $privproto     = 'DES';
my $privkey       = undef;  # added 20220919 by rm
my $seclevel      = undef;  # added 20220919 by rm
my $contextname   = undef;  # added 20220919 by rm
my $disabletotals;          # added 20220921 by rm

#cosmetic changes 20050614 by mw, see old versions for detail
# Added options for bits and second max ifspeed 20100202 by gj
# Added options for specific IP addr to match 20100405 by gj
my $status = GetOptions(
        "h|help"                       => \$opt_h,
        "a|authproto=s"                => \$authproto,
        "A|authpass=s"                 => \$authpass, # changed 20220919 by rm
        "B|bits"                       => \$bits,
        "C|community=s"                => \$COMMUNITY,
        "w|warning=s"                  => \$warn_usage,
        "c|critical=s"                 => \$crit_usage,
        "b|bandwidth|I|inBandwidth=i"  => \$iface_speed,
        "O|outBandwidth=i"             => \$iface_speedOut,
        "f|force"                      => \$force, #added 20130429 by gjf
        "r|noregxp"                    => \$use_reg,           
        "n|contextname=s"              => \$contextname, #added 20220919 by rm
        "S|seclevel=s"                 => \$seclevel, #added 20220919 by rm
        "p|port=i"                     => \$port,
        "u|units=s"                    => \$units,
        "i|interface=s"                => \$iface_descr,
        "H|hostname=s"                 => \$host_address,
        "L|list"                       => \$index_list,
        "d|debug=i"                    => \$debug,
        "user|username=s"              => \$username,
        "v|Version=s"                  => \$snmp_version,
        "M|max=i"                      => \$max_value, #added 20050614 by mw
        "x|privproto=s"                => \$privproto,
        "t|disabletotals"              => \$disabletotals, #added 20220921 by rm
        "q|disableperf=s"              => \$disableperf, #added 20220919 by rm
        "X|privpass=s"                 => \$privpass, #changed 20220919 by rm
        "y|authkey=s"                  => \$authkey, #added 20220919 by rm
        "z|privkey=s"                  => \$privkey, #added 20220919 by rm
        "32|32bit"                     => \$thirtytwo #added 20101104 by gjf
);

# Set internal timeout to address 'Return code of 25 is out of bounds' errors
eval {
	local %SIG;
	$SIG{ALRM}=
		sub{ 
			die "UKNOWN: script timeout\n"; 
			exit -1;
		};
	alarm 15;

# Print help if no options given
if ( $status == 0 ) {
	print_help();
	exit $STATUS_CODE{'OK'};
}

debugout ("DEBUG ENABLED at level: $debug", "1");
debugout ("INTERFACE DESCR: $iface_descr", "2"), if ( defined($iface_descr) );

# Changed 20091214 gj
# Check for missing options
if ( !$host_address )  {
	print  "\nMissing host address!\n\n";
	stop(print_usage(),"OK");
} elsif ( ( $iface_speed ) and ( !$units ) ){
	print "\nMissing units!\n\n";
        stop(print_usage(),"OK");
} elsif ( ( $units ) and ( ( !$iface_speed ) and  ( !$iface_speedOut ) ) ) {
	print "\nMissing (-I or -O) interface maximum speed!\n\n";
	stop(print_usage(),"OK");
} elsif ( ( $iface_speedOut ) and ( !$units ) ) {
	print "\nMissing units (-u) for Out maximum speed!\n\n";
	stop(print_usage(),"OK");
} elsif ( ( $max_value ) and ( !$units ) ) {
	print "\nMissing units (-u) for maximum counter!\n\n";
	stop(print_usage(),"OK");
} elsif ( ( $snmp_version == 3 ) and ( $authpass ) and ( !$username ) ) {
	print "\nMissing version 3 username!\n\n";
	stop(print_usage(),"OK");
} elsif ( ( $snmp_version == 3 ) and ( $privpass ) and ( !$authpass ) ) {
	print "\nMissing version 3 auth password!\n\n";
	stop(print_usage(),"OK");
}
# Set default units if undefined
if ( !defined($units) ){
	#bits
	$units = "b";
}

# Switch output from Bytes to bits if changed on command line
if ($bits) {
	$suffix = "b";
}

# Added to preserve iface native values 20220919 by rm
if ( $iface_speed ) { $max_speed = $iface_speed; }
if ( $iface_speedOut ) { $max_speedOut = $iface_speedOut; } else { $max_speedOut = $iface_speed; }

if ( $iface_speed ) {
	#change 20050414 by mw
	# Added iface_speedOut 20100202 by gj
	# Convert interface speed to Bytes
	debugout("UNIT: $units","3");
	$iface_speed = bits2bytes( $iface_speed, $units );
	if ( $iface_speedOut ) {
		$iface_speedOut = bits2bytes( $iface_speedOut, $units );
	}
}

if ( !$max_value ) {

	# If no -M Parameter was set, set it to 64Bit Overflow
	$max_bytes = 18446744073709600000;    # the value is (2^64)

	if ( defined($thirtytwo) ){
		# If using 32bit counters set to 32bit overflow
		$max_bytes = 4294967296;    # the value is (2^32)
	}
} else {
	# Max value specified, used given value, convert to Bytes
        $max_bytes = unit2bytes( $max_value, $units );
}

debugout ("BYTE COUNTER max_value: $max_bytes", "2");

# Added 20220919 by rm
# disable perfdata if requested
if ($disableperf) {
        if ($disableperf =~ m/a/) { $pdInSpeed = 0; }
        if ($disableperf =~ m/b/) { $pdOutSpeed = 0; }
        if ($disableperf =~ m/c/) { $pdInUsage = 0; }
        if ($disableperf =~ m/d/) { $pdOutUsage = 0; }
        if ($disableperf =~ m/e/) { $pdInBwdth = 0; }
        if ($disableperf =~ m/f/) { $pdOutBwdth = 0; }
        if ($disableperf =~ m/g/) { $pdInAbs = 0; }
        if ($disableperf =~ m/h/) { $pdOutAbs = 0; }
}

####### Can only be set after interface 'speed in' and 'out' and 'max bytes' have all been converted to Bytes
# Bytes
#$units = "B";

# Check snmp version, set snmp parameters
# changed 20220919 by rm

if (!$authpass) { $authpass = $authkey; }
if (!$privpass) { $privpass = $privkey; }

#base snmp arguments
my %snmpargs = (DestHost      => $host_address,
                Version       => $snmp_version,
                RemotePort    => $port,
                Timeout       => $timeout,
);

#snmp v1 and v2c specific arguments
my %snmpv12 = ( Community  => $COMMUNITY, );

#snmpv3 arguments
#base
my %snmpv3 = ( SecName     => $username, );

if ( $username and $authpass and $privpass ) {
        #authPriv
        my %snmpv3ap = ( SecLevel    => 'authPriv',
                         AuthPass    => $authpass,
                         AuthProto   => $authproto,
                         PrivPass    => $privpass,
                         PrivProto   => $privproto, );
        %snmpv3 = ( %snmpv3, %snmpv3ap );
} elsif ( $username and $authpass ) {
        #authNoPriv
        my %snmpv3anp = ( SecLevel    => 'authNoPriv',
                          AuthPass    => $authpass,
                          AuthProto   => $authproto, );
        %snmpv3 = ( %snmpv3, %snmpv3anp );
} else {
        #noAuthNoPriv
        my %snmpv3nanp = ( SecLevel    => 'noAuthNoPriv', );
        %snmpv3 = ( %snmpv3, %snmpv3nanp );
}

if ( $contextname ) { %snmpv3 = ( %snmpv3, Context    => $contextname, ); }

my %snmpv3key = ( AuthLocalizedKey     => $authkey,
                  PrivLocalizedKey     => $privkey, );

if ( $snmp_version le 2 ) {
        %snmpargs = ( %snmpargs, %snmpv12 );
} elsif ( $snmp_version eq 3 ) {
        if ( $authkey or $privkey ) {
                %snmpargs = ( %snmpargs, %snmpv3, %snmpv3key );
        } else {
                %snmpargs = ( %snmpargs, %snmpv3 );
        }
} else {
	$state = 'UNKNOWN';
	stop( "$state: It appears you are missing one or more parameters necessary for v$snmp_version to function.\n",$state );
}
$session = new SNMP::Session( %snmpargs );

debugout("SNMP:\n\tver: $snmp_version\n\tcommunity: $COMMUNITY\n\tport: $port", "3");
if ( $username ) {
	debugout("\n\tuser: $username", "3");
}
if ( $authpass ) {
	debugout("\n\tauth password: $authpass\n\tauth protocol: $authproto", "3");
}
if ( $privpass ) {
	debugout("\n\tpriv password: $privpass\n\tpriv protocol: $privproto", "3");
}

# Moved here 20220919 rm
# convert to IP
if ( $host_address =~ /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/ ) {
} else {
        $host_address = get_ip ( $host_address );
}

# Changed 20220919 rm
# Interface Index was not specified 
if ( !$iface_descr ) {
        $iface_descr = fetch_Ip2IfIndex( $session, $host_address );
}

# Added 20091209 gj
# Detect if a string description was given or a numeric interface index number 
if ( $iface_descr =~ /[^0123456789]+/ ) {
	$iface_number = fetch_ifdescr( $session, $iface_descr );
	debugout("INTERFACE from text string","1"); 
} else {
	$iface_number = $iface_descr;
}

debugout("USING INT#: $iface_number", "2");
debugout("OID's:","2");
debugout("\tIfOperStatus: $snmpIfOperStatus.$iface_number","2");
debugout("\tIfSpeed: $snmpIfSpeed.$iface_number","2");
debugout("\tIfSpeed32: $snmpIfSpeed32.$iface_number","2");
debugout("\tInOctets: $snmpIfInOctets.$iface_number","2");
debugout("\tInOctets32: $snmpIfInOctets32.$iface_number","2");
debugout("\tOutOctets: $snmpIfOutOctets.$iface_number","2");
debugout("\tOutOctets32: $snmpIfOutOctets32.$iface_number","2");

# Get SNMP values, flag errors
debugout("RESULTS:","3");
#my $res_status    = $session->get(new SNMP::Varbind( [$snmpIfOperStatus . "." . $iface_number ] ));

# Changed 20220919 rm
# Simplified
my $res_status     = get_results($snmpIfOperStatus, $iface_number, "Operational Status", "not defined");
$ifspeed64         = get_results($snmpIfSpeed, $iface_number, "Interface Speed (64bit)", "not defined or bad value");
$ifspeed32         = get_results($snmpIfSpeed32, $iface_number, "Interface Speed (32bit)", "not defined");
$inbytes64         = get_results($snmpIfInOctets, $iface_number, "In Bytes (64bit)", "not defined");
$inbytes32         = get_results($snmpIfInOctets32, $iface_number, "In Bytes (32bit)", "not defined");
$outbytes64        = get_results($snmpIfOutOctets, $iface_number, "Out Bytes (64bit)", "not defined");
$outbytes32        = get_results($snmpIfOutOctets32, $iface_number, "Out Bytes (32bit)", "not defined");

if ( defined $res_status ) { $if_status = $res_status; }

# Check interface status, quit check if interface status is error or not '1'.
if ( defined $res_status ){
	if ( $if_status =~ /^DNE -|error|noSuchObject|noSuchInstance/i ) {
		debugout("if_status is not a number\n","4");
		$state = 'UNKNOWN';
		stop("$state: Improper interface status, status received: " . $if_status . "\n",$state);
	} elsif ( $if_status == 1 ) {
		# No action necessary, continue on!
	} elsif ($if_status == 2 ) {
		# Quit, interface is down
		$state = 'CRITICAL';
		stop("$state: Interface is \'down\' (interface: " . $iface_number . " status: " . $if_status . ")\n",$state);
	} elsif ($if_status == 3 ) {
		# Quit, interface is testing
		$state = 'CRITICAL';
		stop("$state: Interface is reporting \'testing\' (interface: " . $iface_number . " status: " . $if_status . ")\n",$state);
	} elsif ($if_status == 4 ) {
		# Quit, interface is unknown
		$state = 'CRITICAL';
		stop("$state: Interface is reporting \'unknown\' (interface: " . $iface_number . " status: " . $if_status . ")\n",$state);
	} elsif ($if_status == 5 ) {
		# Quit, interface is dormant
		$state = 'CRITICAL';
		stop("$state: Interface is reporting \'dormant\' (interface: " . $iface_number . " status: " . $if_status . ")\n",$state);
	} elsif ($if_status == 6 ) {
		# Quit, interface is notPresent
		$state = 'CRITICAL';
		stop("$state: Interface is reporting \'notPresent\' (interface: " . $iface_number . " status: " . $if_status . ")\n",$state);
	} elsif ($if_status == 7 ) {
		# Quit, interface is lowerLayerDown
		$state = 'CRITICAL';
		stop("$state: Interface is reporting \'lowerLayerDown\' (interface: " . $iface_number . " status: " . $if_status . ")\n",$state);
	} else {
		# Interface is in an unknown state
		$state = 'UNKNOWN';
		stop("$state: Interface is reporting unknown status (interface: " . $iface_number . " status: " . $if_status . ")\n",$state);
	}
} else {
	$state = 'UNKNOWN';
	stop("$state: Improper interface status, status received: " . $if_status . "\n",$state);
}

# Determine which values to use
if ( !defined($force) and !defined($thirtytwo) ){
	#default - use 64 then 32 bit values 
	debugout("USING 64 THEN 32 bit VALUES:","4");

	# Speed test
	if ( !$iface_speed ) {
		debugout("\t(Interface speed not provided on command line, determine from host)","4");
		if ( $ifspeed64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i or $ifspeed64 < 1 ){
			debugout("\t\tBad 64bit speed value: $ifspeed64","3");
			if ( $ifspeed32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i or $ifspeed32 < 1 or $ifspeed32 > 4294967295 ){
				debugout("\t\tBad 32bit speed value: $ifspeed32","3");
				$state = 'UNKNOWN';
				stop("$state: No usable interface speed available 64: $ifspeed64 32: $ifspeed32\n",$state);
			} else {
				debugout("\tUsing 32bit speed value: $ifspeed32","3");
				$iface_speed = bits2bytes( $ifspeed32, "b" );
			}
		} else {
			debugout("\tUsing 64bit speed value: $ifspeed64","3");
			# Convert Mbits to bits, bits to Bytes
			$iface_speed = $ifspeed64 * 1000 * 1000;
			$iface_speed = bits2bytes( $iface_speed, "b" );
		}
	}

	# InBytes test
	if ( $inbytes64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 64bit in bytes value: $inbytes64","3");
		if ( $inbytes32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
			debugout("\t\tBad 32bit in bytes value: $inbytes32","3");
			$state = 'UNKNOWN';
			stop("$state: No in bytes available 64: $inbytes64 32: $inbytes32\n",$state);
		} else {
			debugout("\tUsing 32bit in bytes value: $inbytes32","3");
			$in_bytes = $inbytes32;
		}
	} else {
		debugout("\tUsing 64bit in bytes value: $inbytes64","3");
		$in_bytes = $inbytes64;
	}	

	# OutBytes test
	if ( $outbytes64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 64bit out bytes value: $outbytes64","3");
		if ( $outbytes32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
			debugout("\t\tBad 32bit out bytes value: $outbytes32","3");
			$state = 'UNKNOWN';
			stop("$state: No out bytes available 64: $outbytes64 32: $outbytes32\n",$state);
		} else {
			debugout("\tUsing 32bit out bytes value: $outbytes32","3");
			$out_bytes = $outbytes32;
		}
	} else {
		debugout("\tUsing 64bit out bytes value: $outbytes64","3");
		$out_bytes = $outbytes64;
	}	

} elsif ( !defined($force) and defined($thirtytwo) ){
	debugout("USING 32 THEN 64 bit VALUES:","4");

	# Speed test
	if ( !$iface_speed ) {
		debugout("\t(Interface speed not provided on command line, determine from host)","4");
		if ( $ifspeed32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i or $ifspeed32 < 1 or $ifspeed32 >= 4294967295 ){
			debugout("\t\tBad 32bit speed value: $ifspeed32","3");
			if ( $ifspeed64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i or $ifspeed64 < 1 ){
				debugout("\t\tBad 64bit speed value: $ifspeed64","3");
				$state = 'UNKNOWN';
				stop("$state: No usable interface speed available 64: $ifspeed64 32: $ifspeed32\n",$state);
			} else {
				debugout("\tUsing 64bit speed value: $ifspeed64","3");
				# Convert Mbits to bits, bits to Bytes
				$iface_speed = $ifspeed64 * 1000 * 1000;
				$iface_speed = bits2bytes( $iface_speed, "b" );
			}
		} else {
			debugout("\tUsing 32bit speed value: $ifspeed32","3");
			$iface_speed = bits2bytes( $ifspeed32, "b" );
		}
	}

	# InBytes test
	if ( $inbytes32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 32bit in bytes value: $inbytes32","3");
		if ( $inbytes64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
			debugout("\t\tBad 64bit in bytes value: $inbytes64","3");
			$state = 'UNKNOWN';
			stop("$state: No in bytes available 64: $inbytes64 32: $inbytes32\n",$state);
		} else {
			debugout("\tUsing 64bit in bytes value: $inbytes64","3");
			$in_bytes = $inbytes64;
		}
	} else {
		debugout("\tUsing 32bit in bytes value: $inbytes32","3");
		$in_bytes = $inbytes32;
	}	

	# OutBytes test
	if ( $outbytes32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 32bit out bytes value: $outbytes32","3");
		if ( $outbytes64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
			debugout("\t\tBad 64bit out bytes value: $outbytes64","3");
			$state = 'UNKNOWN';
			stop("$state: No out bytes available 64: $outbytes64 32: $outbytes32\n",$state);
		} else {
			debugout("\tUsing 64bit out bytes value: $outbytes64","3");
			$out_bytes = $outbytes64;
		}
	} else {
		debugout("\tUsing 32bit out bytes value: $outbytes32","3");
		$out_bytes = $outbytes32;
	}	

} elsif ( defined($force) and defined($thirtytwo) ){
	debugout("USING 32 bit VALUES ONLY:","4");

	# Speed test
	if ( !$iface_speed ) {
		debugout("\t(Interface speed not provided on command line, determine from host)","4");
		if ( $ifspeed32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i or $ifspeed32 < 1 or $ifspeed32 > 4294967295 ){
			debugout("\t\tBad 32bit speed value: $ifspeed32","3");
			$state = 'UNKNOWN';
			stop("$state: No usable interface speed available: $ifspeed32\n",$state);
		} else {
			debugout("\tUsing 32bit speed value: $ifspeed32","3");
			$iface_speed = bits2bytes( $ifspeed32, "b" );
		}
	}

	# InBytes test
	if ( $inbytes32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 32bit in bytes value: $inbytes32","3");
		$state = 'UNKNOWN';
		stop("$state: No in bytes available: $inbytes32\n",$state);
	} else {
		debugout("\tUsing 32bit in bytes value: $inbytes32","3");
		$in_bytes = $inbytes32;
	}	

	# OutBytes test
	if ( $outbytes32 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 32bit out bytes value: $outbytes32","3");
		$state = 'UNKNOWN';
		stop("$state: No out bytes available: $outbytes32\n",$state);
	} else {
		debugout("\tUsing 32bit out bytes value: $outbytes32","3");
		$out_bytes = $outbytes32;
	}

} elsif ( defined($force) and !defined($thirtytwo) ){
	debugout("USING 64 bit ONLY:","4");

	# Speed test
	if ( !$iface_speed ) {
		debugout("\t(Interface speed not provided on command line, determine from host)","4");
		if ( $ifspeed64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i or $ifspeed64 < 1 ){
			debugout("\t\tBad 64bit speed value: $ifspeed64","3");
			$state = 'UNKNOWN';
			stop("$state: No usable interface speed available: $ifspeed64\n",$state);
		} else {
			debugout("\tUsing 64bit speed value: $ifspeed64","3");
			# Convert Mbits to bits, bits to Bytes
			$iface_speed = $ifspeed64 * 1000 * 1000;
			$iface_speed = bits2bytes( $iface_speed, "b" );
		}
	}

	# InBytes test
	if ( $inbytes64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 64bit in bytes value: $inbytes64","3");
		$state = 'UNKNOWN';
		stop("$state: No in bytes available: $inbytes64\n",$state);
	} else {
		debugout("\tUsing 64bit in bytes value: $inbytes64","3");
		$in_bytes = $inbytes64;
	}	

	# OutBytes test
	if ( $outbytes64 =~ /^DNE -|error|noSuchObject|noSuchInstance/i ){
		debugout("\t\tBad 64bit out bytes value: $outbytes64","3");
		$state = 'UNKNOWN';
		stop("$state: No out bytes available: $outbytes64\n",$state);
	} else {
		debugout("\tUsing 64bit out bytes value: $outbytes64","3");
		$out_bytes = $outbytes64;
	}

}

# Added 20100201 gj
# Check if Out max speed was provided, use same IF speed for both if not
if (!$iface_speedOut) {
	$iface_speedOut = $iface_speed;
}

debugout ("UNITS: $units", "2");
debugout ("Interface speed calculated as: $iface_speed $units", "1");
debugout ("Interface speed OUT: $iface_speedOut $units", "4");

my $row;
my $last_check_time = time - 1;
my $last_in_bytes   = $in_bytes;
my $last_out_bytes  = $out_bytes;

if (
	open( FILE,
		"<" . $TRAFFIC_FILE . $host_address . "_if-" . $iface_number )
  )
{
	while ( $row = <FILE> ) {

		( $last_check_time, $last_in_bytes, $last_out_bytes ) =
		  split( ":", $row );

		### by sos 17.07.2009 check for last_bytes
		if ( ! $last_in_bytes  ) { $last_in_bytes=$in_bytes;  }
		if ( ! $last_out_bytes ) { $last_out_bytes=$out_bytes; }

		if ($last_in_bytes !~ m/\d/) { $last_in_bytes=$in_bytes; }
		if ($last_out_bytes !~ m/\d/) { $last_out_bytes=$out_bytes; }
	}
	close(FILE);
}

my $update_time = time;
debugout ("CURRENT timestamp: $update_time", "1");
debugout ("FILE PATH: $TRAFFIC_FILE" . $host_address . "_if-" . $iface_number, "1");
debugout("READ FROM FILE:\n\tlast time: $last_check_time\n\tlast in bytes: $last_in_bytes\n\tlast out bytes: $last_out_bytes","4");

open( FILE, ">" . $TRAFFIC_FILE . $host_address . "_if-" . $iface_number )
  or die "Can't open $TRAFFIC_FILE for writing: $!";

printf FILE ( "%s:%.0ld:%.0ld\n", $update_time, $in_bytes, $out_bytes );
close(FILE);

debugout("WRITTEN TO FILE:\n\ttime: $update_time\n\tin_bytes: $in_bytes\n\tout bytes: $out_bytes","4");

#added 20050614 by mw
#Check for and correct counter overflow (if possible).
#See function counter_overflow.
$in_bytes  = counter_overflow( $in_bytes,  $last_in_bytes,  $max_bytes );
$out_bytes = counter_overflow( $out_bytes, $last_out_bytes, $max_bytes );

# Calculate traffic since last check (RX\TX) 
my $in_traffic = sprintf( "%.2lf",
	( $in_bytes - $last_in_bytes ) / ( time - $last_check_time ) );
my $out_traffic = sprintf( "%.2lf",
	( $out_bytes - $last_out_bytes ) / ( time - $last_check_time ) );

debugout("in_traffic: $in_traffic\nout_traffic: $out_traffic","1");
# sos 20090717 changed because rrdtool needs bytes
my $in_bytes_abs  = $in_bytes;
my $out_bytes_abs = $out_bytes;

debugout("iface_speed: $iface_speed $units\nin_traffic: $in_traffic\nout_traffic: $out_traffic", "1");

# Calculate usage percentages
my $in_ave_pct  = sprintf( "%.2f", ( 1.0 * $in_traffic * 100 ) / $iface_speed );
my $out_ave_pct = sprintf( "%.2f", ( 1.0 * $out_traffic * 100 ) / $iface_speedOut );

# Don't scale perf data or change it to bits from bytes
$pin_ave = $in_traffic;
$pout_ave = $out_traffic;

if ($bits) {
	# Convert output from Bytes to bits
	$label = "bits";
	$in_tot = $in_bytes * 8;
	$out_tot = $out_bytes * 8;
	$in_ave = $in_traffic * 8;
	$out_ave = $out_traffic * 8;	
} else {
	$label = "Bytes";
	$in_tot = $in_bytes;
	$out_tot = $out_bytes;
	$in_ave = $in_traffic;
	$out_ave = $out_traffic;
}

debugout("OUTPUT:\n\tlabel: $label", "4");
debugout("\tin_tot: $in_tot\n\tout_tot: $out_tot\n\tin_ave: $in_ave\n\tout_ave: $out_ave", "4");
debugout("\tin_ave_pct: $in_ave_pct\n\tout_ave_pct: $out_ave_pct\n\tin_bytes_abs: $in_bytes_abs\n\tout_bytes_abs: $out_bytes_abs", "4");

# Scale ave and tot for output
$in_tot = unit2scale($in_tot, $units);
$out_tot = unit2scale($out_tot, $units);
$in_ave = unit2scale($in_ave, $units);
$out_ave = unit2scale($out_ave, $units);

# Convert from Bytes/bits to megaBytes/bits
$in_bytes  = sprintf( "%.2f", $in_bytes / (1024 * 1000) );
$out_bytes = sprintf( "%.2f", $out_bytes / (1024 * 1000) );

# Changed 20091209 gj, updated 20130424 gj
# Check/Set state of service check
if ( ( $in_ave_pct < $warn_usage ) and ( $out_ave_pct < $warn_usage ) ) {
	$state = 'OK';
	$output =
	"$state - Average IN: "
	  . $in_ave . $suffix . "ps (" . $in_ave_pct . "%), " 
	  . "Average OUT: " . $out_ave . $suffix . "ps (" . $out_ave_pct . "%)";
        # changed 20220921
        # allowed this output to be disabled
	if ( !$disabletotals ) { $output .= " Total RX: $in_tot" . "$label, Total TX: $out_tot" . "$label"; }
} elsif ( $in_ave_pct > $crit_usage ) {
	$state = 'CRITICAL';
	$output = "$state - IN bandwidth ($in_ave_pct%) too high";
} elsif ( $out_ave_pct > $crit_usage ) {
	$state = 'CRITICAL';
	$output = "$state - OUT bandwidth ($out_ave_pct%) too high";
} elsif ( $in_ave_pct > $warn_usage ) {
	$state = 'WARNING';
	$output = "$state - IN bandwidth ($in_ave_pct%) too high";
} elsif ( $out_ave_pct > $warn_usage ) {
	$state = 'WARNING';
	$output = "$state - OUT bandwidth ($out_ave_pct%) too high";
}


# Changed 20091214 gj - commas should have been semicolons
# Changed 20220919 rm - each perf output needs four semicolons.  Also made 
# perfdata output custom depending on needs

$output .= "|"; 
if ($pdInSpeed) { 
        $output .= "inSpeed=$in_ave";
        if ( $suffix =~ /[b]/ ) { 
                $output .= lc $suffix;
        } else {
                $output .= $suffix;
        }
        $output .= "ps;;;0;$max_speed ";
} 
if ($pdOutSpeed) {
        $output .= "outSpeed=$out_ave";
        if ( $suffix =~ /[b]/ ) {
                $output .= lc $suffix;
        } else {
                $output .= $suffix;
        }
        $output .= "ps;;;0;$max_speedOut ";
} 
if ($pdInUsage) { $output .= "inUsage=$in_ave_pct%;$warn_usage;$crit_usage;; "; }
if ($pdOutUsage) { $output .= "outUsage=$out_ave_pct%;$warn_usage;$crit_usage;; "; }
if ($pdInBwdth) { $output .= "inBandwidth=" . $pin_ave . "B;;;; "; }
if ($pdOutBwdth) { $output .= "outBandwidth=" . $pout_ave . "B;;;; "; }
if ($pdInAbs) {  $output .= "inAbsolut=$in_bytes_abs" . "c;;;; "; }
if ($pdOutAbs) { $output .= "outAbsolut=$out_bytes_abs" . "c;;;;"; }
debugout ("",1);
stop($output, $state);


# end of internal timeout eval group
alarm 0;
};

sub fetch_Ip2IfIndex {
	my $state;
	my @IPInterfaces;
        my @AllInterfaces;

	my $snmpkey;
	my $key;

        my $n = 0;

	my ( $session, $host ) = @_;

        @IPInterfaces = $session->bulkwalk(0, 1000, new SNMP::VarList([$snmpIPAdEntIfIndex]));
        @AllInterfaces = $session->bulkwalk(0, 1000, new SNMP::VarList([$snmpIfDescr]));
	# Quit if results not found
        if ($session->{ErrorNum}) {
		$state = 'CRITICAL';
                stop ("$state: Interface index not detected ERROR: $session->{ErrorStr}",$state);
        } 

        # Changed 20220919 rm
        # Formatting changes and adding ability to list all interfaces not just IP based ones
	if ( $index_list ){
		print ("\n[Interfaces with IPs found:]\n");
		print ("  IP Addr\t\t\tIndex\n");
		print ("----------------------------------------\n");
	}
	# Check each returned value
        while ( $n < scalar( @{ $IPInterfaces[0] }) ) {
		if ( $index_list ){
			printf ("%-25s", "$IPInterfaces[0][$n][1]");
                        print "\t  $IPInterfaces[0][$n][2]\n";
		}

		# Check for ip address match in returned index results
		if ( $IPInterfaces[0][$n][1] =~ /$host$/ ) {
			$snmpkey = $IPInterfaces[0][$n][2];
		}
                $n++;
	}
        $n = 0;
        if ( $index_list ){
                print ("\n[All Interfaces:]\n");
                print ("    Interface\t\t\tIndex\n");
                print ("----------------------------------------\n");
                while ( $n < scalar( @{ $AllInterfaces[0] }) ) {
                        printf ("%-25s", "$AllInterfaces[0][$n][2]");
                        print "\t  $AllInterfaces[0][$n][1]\n";
                $n++;
                }
                $state = 'OK';
                stop("$state: Listed current interfaces.",$state);
        }

	unless ( defined $snmpkey ) {
		$state = 'CRITICAL';
		stop("$state: Could not find index matching $host",$state);
	}
	return $snmpkey;
}

sub fetch_ifdescr {
	my $state;
	my $resp;
        my @response;
	my $snmpkey;
	my $answer;
	my $key;

        my $n = 0;

	my ( $session, $ifdescr ) = @_;

        # Changed 20220919 rm
        # Converted from Net::SNMP to SNMP
        @response = $session->bulkwalk(0, 1000, new SNMP::VarList([$snmpIfDescr]));
        # Quit if results not found
        if ($session->{ErrorNum}) {
                $state = 'CRITICAL';
                exit $STATUS_CODE{$state};
        }

        while ($n < scalar( @{ $response[0] } ) ) {
                if ($response[0][$n][2] =~ /^$ifdescr$/) {
                        $snmpkey = $response[0][$n][1];
                        debugout("\t$ifdescr = $snmpkey","2");
                }

            $n++;
        }

	unless ( defined $snmpkey ) {
		$state = 'CRITICAL';
		printf "$state: Could not match $ifdescr \n";
		exit $STATUS_CODE{$state};
	}
	return $snmpkey;
}

#added 20050416 by mw
#Converts an input value to value in bits
sub bits2bytes {
	return unit2bytes(@_) / 8;
}

#added 20050416 by mw
#Converts an input value to value in bytes
sub unit2bytes {
	my ( $value, $unit ) = @_;

	if ( $unit eq "g" ) {
		return $value * 1000 * 1000 * 1000;
	}
	elsif ( $unit eq "m" ) {
		return $value * 1000 * 1000;
	}
	elsif ( $unit eq "k" ) {
		return $value * 1000;
	}
	elsif ( $unit eq "b" ) {
		return $value * 1;
	}
	else {
		print "You have to supply a supported unit (g,m,k,b)\n";
		exit $STATUS_CODE{'UNKNOWN'};
	}
}

sub unit2scale {
	# Scale output, expecting Bits\Bytes input
	my ($val, $units) = @_;
	my $prefix = "";


        # changed 20220919
        if ( $units eq "k" ) {
		$val = sprintf( "%.2f", $val / 1000 );
		$prefix = "K";
	}
        if ( $units eq "m" ) {
		$val = sprintf( "%.2f", $val / 1000 / 1000 );
		$prefix = "M";
	}
        if ( $units eq "g" ) {
		$val = sprintf( "%.2f", $val / 1000 / 1000 / 1000 );
		$prefix = "G";
	}
	return $val . $prefix;
}

# Convert from Bytes/bits to megaBytes/bits
# added 20050414 by mw
# This function detects if an overflow occurs. If so, it returns
# a computed value for $bytes.
# If there is no counter overflow it simply returns the original value of $bytes.
# IF there is a Counter reboot wrap, just use previous output.
sub counter_overflow {
	my ( $bytes, $last_bytes, $max_bytes ) = @_;

	$bytes += $max_bytes if ( $bytes < $last_bytes );
	$bytes = $last_bytes  if ( $bytes < $last_bytes );
	return $bytes;
}

# Added 20100202 by gj
# Print results and exit script
sub stop {
	my $result = shift;
	my $exit_code = shift;
	print $result . "\n";
	exit ( $STATUS_CODE{$exit_code} );
}

# Added 20100405 by gj
# Lookup hosts ip address
sub get_ip {
	use Net::DNS;

	my ( $host_name ) = @_;

	my $res = Net::DNS::Resolver->new;
	my $query = $res->search($host_name);

	if ($query) {
		foreach my $rr ($query->answer) {
			next unless $rr->type eq "A";
			return $rr->address;
		}
	} else {
		
		stop("Error: IP address not resolved","UNKNOWN");
	}
}

# Added 20220919 rm
# Grab SNMP results
sub get_results {
        my ($oid, $inum, $smsg, $emsg) = @_;

        my $result = $session->get(new SNMP::Varbind( [$oid . "." . $inum ] ));
        if ($session->{ErrorNum}) {
                $result = "DNE - $session->{ErrorStr}";
                debugout("\t$smsg $emsg!: DNE - $session->{ErrorStr}","2");
        } else {
                debugout("\t$smsg: $result","3");
        }
        return $result;
}

sub debugout {

	my ( $text, $level ) = @_;

	if ( $level <= $debug) {
		print "$text\n";
	}
}

#cosmetic changes 20050614 by mw
#Couldn't sustain "HERE";-), either.
sub print_usage {
	print <<EOU;
    Usage: check_iftraffic64.pl -H host [ -C community_string ] [ -i if_index|if_descr ] [ -r ] [ -b if_max_speed_in | -I if_max_speed_in ] [ -O if_max_speed_out ] [ -u ] [ -B ] [ --32bit ] [ -f ] [ -L ] [ -M ] [ -w warn ] [ -c crit ] [ -v 1|2|3 ] [ --username <username> ] [ --contextname <contextname> ] [ --authpassword <authpassword> ] [ --authprotocol MD5|SHA ] [ --privpassword <privpassword> ] [ --privprotocol DES|3DES|AES|AES192|AES256|AES256C ] [ --authkey <authkey> ] [ --privkey <privkey> ] [ -q abcdefgh ] [ -t ]

    Example 1: check_iftraffic64.pl -H host1 -C sneaky
    Example 2: check_iftraffic64.pl -H host1 -C sneaky -i "Intel Pro" -r -B  
    Example 3: check_iftraffic64.pl -H host1 -C sneaky -i 5
    Example 4: check_iftraffic64.pl -H host1 -C sneaky -i 5 -B -b 100 -u m --32bit
    Example 5: check_iftraffic64.pl -H host1 -C sneaky -i 5 -B -I 20 -O 5 -u m 
    Example 6: check_iftraffic64.pl -H host1 -C sneaky -A 192.168.1.1 -B -b 100 -u m 
    Example 7: check_iftraffic64.pl -H host1 -C sneaky -A 192.168.1.1 --force --32bit 
    Example 8: check_iftraffic64.pl -H host1 --username admin --authpassword sneaky  
    Example 9: check_iftraffic64.pl -H host1 --username admin --authpassword sneaky123 --privpassword reallysneaky --privprotocol 3DES  

    Options:


    -b, --bandwidth INTEGER
    -I, --inBandwidth INTEGER
        Interface maximum speed in kilo/mega/giga/bits per second. Applied to 
	both IN and OUT if out (-O) max speed is not provided. Requires -u.
    -O, --outBandwidth INTEGER
        Interface maximum speed in kilo/mega/giga/bits per second. Applied to
	OUT traffic.  Uses the same units value given for -b. Requires -u. 
    -i, --interface STRING
        Interface Name
    -M, --max INTEGER
	Max Counter Value (in bits) of net devices in giga/mega/kilo/bits. Requires -u.
    -r, --regexp
        Use regexp to match NAME in description OID
    -u, --units STRING
        g=gigabits/s,m=megabits/s,k=kilobits/s,b=bits/s. Required if -b, -I, -M,
	or -O are used.
    -C, --community STRING 
        SNMP Community.
    -H, --host STRING or IPADDRESS
        Check interface on the indicated host.
    -c, --critical INTEGER
        % of bandwidth usage necessary to result in critical status (default: 98%)
    -w, --warning INTEGER
        % of bandwidth usage necessary to result in warning status (default: 85%)
    --32bit FLAG
	Set to use 32 bit counters instead of 64 bit (default: 64 bit).
    -B, --bits FLAG
	Display results in bits per second b/s (default: Bytes/s)
    -f, --force FLAG
	Set to force either 64 bit or 32 bit only checking (32 bit requires --32bit flag).
    -d, --debug INTEGER
	Output some debug info, not supported inside of Nagios but may be useful
	from the command line.  Levels 1-4 can be specified, 4 being the most information.
    -h, --help
	Displays this help text
    -L, --list FLAG (on/off)
	Tell plugin to list available interfaces. This is not supported inside 
	of Nagios but may be useful from the command line.
    -v, --Version STRING
	Set SNMP version (defaults to 2).  Version 2 or 3 required for 64 bit counters.
    -S, --seclevel=STRING
        Security level for SNMPv3 connection  (noAuthNoPriv, authNoPriv, authPriv)
    -A, --authpass=STRING
        SNMPv3 authentication password
    -a, --authproto=STRING
        SNMPv3 authentication protocol
    -t, --disabletotals
        Disables RX and TX Total output
    -q, --disableperf=STRING
        Disable specific perfdata 
        (a - InSpeed, b - OutSpeed, c - InUsage, d - OutUsage, e - InBwdth, f - OutBwdth, g - InAbsolute, f - OutAbsolute)
    -y, --authkey=STRING
        SNMPv3 authentication key
    -X, --privpass=STRING
        SNMPv3 privacy password
    -x, --privproto=STRING
        SNMPv3 privacy protocol
    -z, --privkey=STRING
        SNMPv3 privacy key
EOU

}
